/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#[link(name = "servo",
       vers = "0.1",
       uuid = "637ffc98-9058-471d-9de7-abfc49ef0549",
       url = "http://servo.org/")];

#[comment = "The Servo Parallel Browser Project"];
#[license = "MPL"];
#[crate_type = "lib"];

#[feature(globs, macro_rules, managed_boxes)];

extern mod alert;
extern mod azure;
extern mod extra;
extern mod geom;
extern mod gfx (name = "gfx");
#[cfg(not(target_os="android"))]
extern mod glfw;
#[cfg(target_os="android")]
extern mod glut;
extern mod js;
extern mod layers;
extern mod opengles;
extern mod png;
extern mod sandbox;
extern mod script;
extern mod servo_net (name = "net");
extern mod servo_msg (name = "msg");
extern mod servo_util (name = "util");
extern mod stb_image;
extern mod style;

#[cfg(target_os="macos")]
extern mod core_graphics;
#[cfg(target_os="macos")]
extern mod core_text;
#[cfg(target_os="macos")]
extern mod io_surface;

use compositing::CompositorTask;
use constellation::{Constellation, ConstellationMsgDeliveryTask};
use servo_msg::compositor_msg::{CompositorComm};
use servo_msg::constellation_msg::{ConstellationComm, ConstellationStream};

#[cfg(not(test))]
use gfx::opts;

pub use gfx::opts::Opts;
pub use gfx::text;
pub use servo_util::url::make_url;

use sandbox::{OpenGLMode, RestrictedMode};
use servo_net::image_cache_task::ImageCacheTask;
use servo_net::resource_task::ResourceTask;
use servo_util::ipc::NativeUnixStream;
use servo_util::time::{Profiler, ProfilerChan};
use std::cast;
use std::cell::Cell;
use std::c_str::CString;
use std::comm::SharedChan;
use std::comm;
use std::libc::{c_int, uintptr_t};
use std::libc;
use std::os;
use std::ptr;
use std::rt;
use std::task::SingleThreaded;
use std::task;
use std::vec;

#[path="compositing/mod.rs"]
pub mod compositing;

pub mod macros;

pub mod css {
    mod node_util;

    pub mod select;
    pub mod matching;
    pub mod node_style;
}

pub mod constellation;
pub mod pipeline;

pub mod layout {
    pub mod block;
    pub mod box;
    pub mod box_builder;
    pub mod context;
    pub mod display_list_builder;
    pub mod float_context;
    pub mod float;
    pub mod flow;
    pub mod layout_task;
    pub mod inline;
    pub mod model;
    pub mod text;
    pub mod util;
    pub mod incremental;
    mod aux;
}

pub mod windowing;

#[path="platform/mod.rs"]
pub mod platform;

#[path = "util/mod.rs"]
pub mod util;

/// The top-level entry point.
#[cfg(not(test))]
#[start]
fn start(argc: int, argv: **u8) -> int {
    #[cfg(target_os="linux")]
    #[cfg(target_os="macos")]
    fn getopts(argc: int, argv: **u8) -> Opts {
        let args = vec::from_fn(argc as uint, |i| unsafe {
            let c_str = CString::new(cast::transmute(*ptr::offset(argv, i as int)), false);
            c_str.as_str().unwrap().to_str()
        });
        opts::from_cmdline_args(args)
    }
    #[cfg(target_os="android")]
    fn getopts(_: int, _: **u8) -> Opts {
        let mut args:~[~str] = ~[];
        args.push(~"servo");
        let servo_url = os::getenv(~"SERVO_URL");
        match servo_url {
            Some(s) => { args.push(s); },
            None => { fail!("No url input"); }
        }
        opts::from_cmdline_args(args)
    }


    // Set up multiprocess operation. First, create a socket pair.
    let (constellation_unix_stream, compositor_unix_stream) = NativeUnixStream::pair();

    // Parse command line arguments.
    let opts = getopts(argc, argv);

    // Fork into processes or threads as directed.
    if opts.single_process {
        run_in_single_process_mode(argc,
                                   argv,
                                   opts,
                                   compositor_unix_stream,
                                   constellation_unix_stream)
    } else {
        run_in_multiprocess_mode(argc,
                                 argv,
                                 opts,
                                 compositor_unix_stream,
                                 constellation_unix_stream)
    }
}

extern {
    fn rust_get_num_cpus() -> uintptr_t;
}

fn run_in_single_process_mode(argc: int,
                              argv: **u8,
                              opts: Opts,
                              compositor_unix_stream: NativeUnixStream,
                              constellation_unix_stream: NativeUnixStream)
                              -> int {
    do std::rt::start_on_main_thread(argc, argv) {
        let opts = opts.clone();
        let opts_clone = opts.clone();
        do task::spawn {
            run_content_process(opts_clone.clone(), false, constellation_unix_stream)
        }
        run_compositor_process(opts, compositor_unix_stream)
    }
}

fn run_in_multiprocess_mode(argc: int,
                            argv: **u8,
                            opts: Opts,
                            compositor_unix_stream: NativeUnixStream,
                            constellation_unix_stream: NativeUnixStream)
                            -> int {
    // Fork into two processes.
    unsafe {
        if fork() != 0 {
            do std::rt::start_on_main_thread(argc, argv) {
                run_compositor_process(opts.clone(), compositor_unix_stream)
            }
        } else {
            do std::rt::start(argc, argv) {
                run_content_process(opts.clone(), true, constellation_unix_stream)
            }
        }
    }
}

/// A wrapper around `fork`. This is unsafe because `libuv` doesn't like forking.
#[fixed_stack_segment]
unsafe fn fork() -> c_int {
    libc::fork()
}

/// The entry point for the high-privilege compositor process.
fn run_compositor_process(opts: Opts, compositor_unix_stream: NativeUnixStream) {
    // Set up the profiler.
    let (profiler_port, profiler_chan) = special_stream!(ProfilerChan);
    Profiler::create(profiler_port, profiler_chan.clone(), opts.profiler_period);

    let compositor_end = CompositorComm::init(compositor_unix_stream);
    let mut compositor_task = CompositorTask::new(opts, compositor_end, profiler_chan);
    compositor_task.run();
}

/// The entry point for the low-privilege content process.
fn run_content_process(opts: Opts, sandbox: bool, constellation_unix_stream: NativeUnixStream) {
    // Set up the profiler.
    let (profiler_port, profiler_chan) = special_stream!(ProfilerChan);
    Profiler::create(profiler_port, profiler_chan.clone(), opts.profiler_period);

    // Set up a bunch of channels.
    let (compositor_to_constellation_port, compositor_to_constellation_chan) = comm::stream();
    let constellation_chan = SharedChan::new(compositor_to_constellation_chan);
    let constellation_stream = ConstellationStream::init(constellation_unix_stream);
    let constellation_end = ConstellationComm::init(compositor_to_constellation_port,
                                                    constellation_chan.clone(),
                                                    constellation_stream);

    // Set up the delivery task, which is a workaround for Rust's inability to select over I/O.
    let constellation_chan_clone = Cell::new(constellation_chan.clone());
    let mut task = task::task();
    task.unlinked();
    task.sched_mode(SingleThreaded);
    do task.spawn {
        let mut task = ConstellationMsgDeliveryTask::init(constellation_stream,
                                                          constellation_chan_clone.take());
        task.run()
    }

    // Create the resource and image cache tasks.
    //
    // FIXME(pcwalton): The resource task should go in the trusted compositor process.
    let resource_task = ResourceTask();
    let image_cache_task = ImageCacheTask(resource_task.clone());

    // Enter the sandbox, if desired.
    //
    // FIXME(pcwalton): Should be able to be more restrictive, but `CGLChoosePixelFormat` will
    // fail otherwise. Bummer.
    if sandbox {
        sandbox::enter(OpenGLMode);
    }

    // Create and start the constellation.
    Constellation::start(constellation_end,
                         opts,
                         resource_task,
                         image_cache_task,
                         profiler_chan.clone());
}

